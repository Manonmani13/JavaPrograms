   @GET
    @Timed
    @Path("linkedInApi")
    @TenantResolution
    public ApiResponse getProfileInfo(@AuthParam AuthToken authToken) throws  ParseException, NoSuchAlgorithmException, KeyManagementException, MalformedURLException {
        JSONObject result = this.service.getProfileInfo(authToken);
        return ApiResponse.buildWithPayload(new Payload<JSONObject>().addObject(result)).setStatus(Response.Status.OK);
    }


  public JSONObject getProfileInfo(AuthToken authToken) throws ParseException, NoSuchAlgorithmException, KeyManagementException, MalformedURLException {
        String client_id = "86v633uzjlp1sq";
        String redirectUrl = "https%3A%2F%2Fhttps://dev-platform.engage2serve.com/%2F";
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {

            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            /*  public void checkClientTrusted(X509Certificate[] certs, String authType) { }
              public void checkServerTrusted(X509Certificate[] certs, String authType) { }
              */
            @Override
            public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }

            @Override
            public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }
        }};

        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        Client client = ClientBuilder.newClient();
        WebTarget webTargets = client.target("www.linkedin.com/oauth/v2/authorization?response_type=code&client_id="+client_id+"&redirect_uri="+redirectUrl+"state=jfkdnfaoinowe&scope=r_basicprofile");
       /* webTargets.queryParam("response_type", "code");
        webTargets.queryParam("client_id", client_id);
        webTargets.queryParam("direct_url", redirectUrl);
        webTargets.queryParam("state", "nvkdjlwnkdpoenls");
        webTargets.queryParam("scope", "r_basicprofile");*/

        Invocation.Builder invocationBuilder = webTargets.request(MediaType.APPLICATION_JSON);
        Response response = invocationBuilder.post(Entity.json(webTargets));
        JSONObject code = null;
        if (response.getStatus() == javax.ws.rs.core.Response.Status.OK.getStatusCode()) {
            // dbs name getting successfully
            JSONObject data = response.readEntity(JSONObject.class);

            String code2 = data.get("code") != null ? data.get("code").toString() : "";
            code = requestingToken(code2);

        }
        return code;
    }

    public JSONObject requestingToken(String token) throws ParseException, NoSuchAlgorithmException, KeyManagementException, MalformedURLException {

        String clientId = "86v633uzjlp1sq";
        String clientSecret = "e5f6XL3M6Js64rem";
        String redirectUrl = "https%3A%2F%2Fhttps://dev-platform.engage2serve.com/%2F";
        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            /*  public void checkClientTrusted(X509Certificate[] certs, String authType) { }
              public void checkServerTrusted(X509Certificate[] certs, String authType) { }
              */
            @Override
            public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }

            @Override
            public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }
        }};

        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        Client client = ClientBuilder.newBuilder().sslContext(sc).newClient();

        WebTarget webTargets = client.target("www.linkedin.com/oauth/v2/accessToken?grant_type=authorization_code&code="+token+"&redirect_uri="+redirectUrl+"&client_id="+clientId+"&client_secret="+clientSecret);
        Invocation.Builder invocationBuilder = webTargets.request(MediaType.APPLICATION_FORM_URLENCODED);
   /*     webTargets.queryParam("grant_type", "authorization_code");
        webTargets.queryParam("code", token);
        webTargets.queryParam("direct_url", redirectUrl);
        webTargets.queryParam("client_id", clientId);
        webTargets.queryParam("client_secret", clientSecret);*/
        Response response = invocationBuilder.post(Entity.json(webTargets));
        JSONObject accessToken = null;
        if (response.getStatus() == javax.ws.rs.core.Response.Status.OK.getStatusCode()) {
            // dbs name getting successfully
            JSONObject data = response.readEntity(JSONObject.class);

            String authtoken = data.get("accessToken") != null ? data.get("accessToken").toString() : "";
            accessToken = profileInfo(authtoken);
        }
        return accessToken;
    }

    public JSONObject profileInfo(String accessToken) throws  NoSuchAlgorithmException, KeyManagementException, MalformedURLException {
        //  accessToken = jObjSession.get("access_token").toString();

        TrustManager[] trustAllCerts = new TrustManager[]{new X509TrustManager() {
            public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            /*  public void checkClientTrusted(X509Certificate[] certs, String authType) { }
              public void checkServerTrusted(X509Certificate[] certs, String authType) { }
              */
            @Override
            public void checkClientTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }

            @Override
            public void checkServerTrusted(X509Certificate[] arg0, String arg1) throws CertificateException {
                // TODO Auto-generated method stub

            }
        }};

        SSLContext sc = SSLContext.getInstance("SSL");
        sc.init(null, trustAllCerts, new java.security.SecureRandom());
        HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());
        // Create all-trusting host name verifier
        HostnameVerifier allHostsValid = new HostnameVerifier() {
            public boolean verify(String hostname, SSLSession session) {
                return true;
            }
        };
        // Install the all-trusting host verifier
        HttpsURLConnection.setDefaultHostnameVerifier(allHostsValid);
        Client clients = ClientBuilder.newBuilder().sslContext(sc).newClient();
        WebTarget webTargets = clients.target("https://api.linkedin.com/v2/me");
        Invocation.Builder invocationBuilder = webTargets.request(MediaType.TEXT_PLAIN);
        invocationBuilder.header("Authorization", "Bearer " + accessToken);
        Response response = invocationBuilder.get();
        JSONObject info = null;
        if (response.getStatus() == Response.Status.OK.getStatusCode()) {
            info = response.readEntity(JSONObject.class);
        }
        return info;
    }






